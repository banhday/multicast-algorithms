-------------------------------- MODULE Zab --------------------------------

EXTENDS Integers,  FiniteSets, Sequences, Naturals, TLC

(***************** START: VARIABLE & CONSTANT DECLARATIONS ******************* 

    - The set of servers are encoded as a set of natural numbers {1, ..., N}.
    - Every majority of servers has at least MajorGuard elements. 
 *) 
 
a <: b == a
 
CONSTANT N, Server, ServerSeq                    
ASSUME N = Cardinality(Server)                
MajorGuard == (N \div 2) + 1  

(*
RECURSIVE ToSeq(_)

ToSeq(set) ==
  IF set = {} THEN << >>
  ELSE LET elem == CHOOSE x \in set : TRUE
       IN Append(ToSeq(set \ {elem}), elem)

ServerSeq == ToSeq(Server)
*)


(* Ballots
    - BallotMax: the maximum ballot which is required to construct a finite bound
    - ballot, cballot: a function from Server to BallotRange
    - ballot = 0: only in the initialized sate. There is no leader in ballot 0, and every server is
      a follower.
 *)
CONSTANT BallotMax           
VARIABLE ballot, cballot     
BallotRange == 0..BallotMax
BallotNull == -1



(* The user needs to instantiate this function. In one ballot, many servers can become a leader, and  the majority of 
   servers needs to agree which is a leader. I initialized IsLeader with a round-robin function in my experiments, and 
   therefore only one server can become a leader in every ballot. In the initial state, all servers are follower.
 *) 
IsLeader == [b \in 1..BallotMax |-> ServerSeq[(b % N) + 1]]      

(*  - BcastMsgInSeq: a sequence of Broadcast messages which are natural numbers
    - BcastMsg: a set of Broadcast messages which are elements of BcastMsgInSeq
    - BcastMsgNull: is used in the construction of variables bcastMsgLog and delivered. However, 
      it seems that BcastMsgNull is not necessary.
      - TODO: eliminate BcastMsgNull
 *)   

CONSTANT BcastMsg, BcastMsgInSeq, BcastMsgInSeqLen
(* 
BcastMsg == {}
*) 


(*
BcastMsgInSeq == ToSeq(BcastMsg)
*) 
BcastMsgNull == -1 
ASSUME BcastMsgNull \notin BcastMsg

(*  - bcastMsgLog: a sequence of Broadcast messages logged by a server
    - SlotMax: a maximum number of Broadcast messages logged by a server. Because every Broadcast message 
      is received by a leader exactly one time (with action HandleBcastMsg), the length ofbcastMsgLog[p] 
      is bounded by Len(BcastMsgInSeq) for every server p.
    - SlotValue: all values which a slot of bcastMsgLog can contain  
    - EmptyLog: no Broadcast message is stored 
    - LogInstance: all instances of logs for Broadcast messages. For example, if BcastMsgInSeq is <1, 2, 3>, 
      an instance of bcastMsgLog[1] might be <1, 3>. This scenario happens when 
        (1) Broadcast message 1 is committed,
        (2) The leader 1 crashes after sending Accept(2) for Broadcast message 2,
        (3) Server 2 is voted as a new leader but no server receives Accept(2),
        (4) Server 2 receives Broadcast message 3 and sends Accept(3) to all.
    - Notice that the above scenario is not really correct in Zab because of the way we model Broadcast 
      message. We use this scenario or similar ones only for model checking purposes. In Zab, Broadcast 
      messages are updates for servers. Therefore, Broadcast messages should be generated by a deterministic 
      function, and server 2 should recognise that the next Broadcast message is 2, not 3.
      - TODO: implement a deterministic function to generate Broadcast messages.
 *)
VARIABLE bcastMsgLog
SlotMax == Len(BcastMsgInSeq)                              
SlotRange == 1..SlotMax  
SlotValue == {BcastMsgNull} \cup BcastMsg
EmptyLog == << >> 
LogInstance == ( UNION { [(1..maxSlot) -> SlotValue] : maxSlot \in SlotRange } ) \cup {EmptyLog}


(* All kinds of messages between servers and servers in the protocol
 *)
(*  
Accept == 1
AcceptAck == 2
Commit == 3
NewLeader == 4
NewLeaderAck == 5
NewState == 6
NewStateAck == 7
 *)
CONSTANT Accept, AcceptAck, Commit, NewLeader, NewLeaderAck, 
                  NewState, NewStateAck
                  
MsgStatus == { Accept, AcceptAck, Commit, NewLeader, NewLeaderAck, 
                  NewState, NewStateAck }   
MsgStatus_NormalCase == { Accept, AcceptAck, Commit }
MsgStatus_RecoveringCase == { NewLeader, NewLeaderAck, NewState, NewStateAck }                        
                                                                       
(* All kinds of messages sent by Server 
 *)
AcceptInfo == [type : {Accept}, bcast : BcastMsg, ballot : BallotRange, 
                  slot : SlotRange]

AcceptAckInfo == [type : {AcceptAck}, ballot : BallotRange, slot : SlotRange]

CommitInfo == [type : {Commit}, ballot : BallotRange, slot : SlotRange, 
                  bcast : BcastMsg]

NewLeaderInfo == [type : {NewLeader}, ballot : BallotRange]

NewLeaderAckInfo == [type : {NewLeaderAck}, ballot : BallotRange, 
                          cballot : BallotRange, log : LogInstance]                    
                  
NewStateInfo == [type : {NewState}, ballot : BallotRange, log : LogInstance]

NewStateAckInfo == [type : {NewStateAck}, ballot : BallotRange]

Message_NormalCase == [source : Server, dest : Server, data : AcceptInfo \cup AcceptAckInfo \cup CommitInfo]                        

Message_RecoveringCase == [source : Server, dest : Server, data : NewLeaderInfo \cup NewLeaderAckInfo \cup NewStateInfo \cup NewStateAckInfo]


Message == Message_NormalCase \cup Message_RecoveringCase
                         
              
(* Server statuses 
    - Status: all statuses which a server can has in every execution
    - { Leader, Follower }: for correct servers
    - status: records the current status of every server, and is a function from Server to Status.
 *)
VARIABLE status
CONSTANT Leader, Follower, Recovering
(*
Leader == 1
Follower == 0
Recovering == -1
 *)
Status == { Leader, Follower, Recovering }


(* Just the normal max function
 *)
Max(x, y) == IF x > y THEN x ELSE y                         

          
(*  - last_delivered[s]: the index of last Broadcast message which is delivered by server s.
    - rcvdMsg: records messages which a server has received, and is encoded as a function from Server to 
      the power set of Message.
    - inTransit: point-to-point FIFO communication channels that records messages intransit and is encoded
      as sequences. 
    - front: functions from Server to another function from Server to Int. This function is used to know 
      which message is the next one to receive, and to avoid remove a message from the head of a sequence. 
    - delivered: sequences of Broadcast messages which are delivered by servers 
    - bcasted: knows which messages in BcastMsgInSeq are processed with HandleBcastMsg.
 *) 
VARIABLE lastDelivered, rcvdMsg_NormalCase, rcvdMsg_RecoveringCase, inTransit, front, delivered, bcasted                      

(* All variables
 *)
vars == << bcastMsgLog, ballot, cballot, status, lastDelivered, rcvdMsg_NormalCase, rcvdMsg_RecoveringCase, inTransit, front,   
              delivered, bcasted >> 

(******************* END: VARIABLE & CONSTANT DECLARATIONS *******************
 *)


(********************** START: TYPE INVARIANT & SAFETY *********************** 
    
    - TLC is used to check for properties: Type Invariant, Integrity_AtMostOnce, Validity, and AsymmetricOrder
    - Fairness: has not been encoded
    - Liveness: no specified

   Type Invariant: 
      - Type information for every variable.
      - Can we remove the constraint bcastMsgLog[s][k] = BcastMsgNull in TypeInv?
 *)
 (*       
TypeInv == 
  /\ \A s \in Server : \A k \in DOMAIN bcastMsgLog[s] : 
        \/ \E k0 \in DOMAIN BcastMsgInSeq : bcastMsgLog[s][k] = BcastMsgInSeq[k0]
        \/ bcastMsgLog[s][k] = BcastMsgNull  
  /\ ballot \in [Server -> BallotRange]
  /\ cballot \in [Server -> BallotRange]
  /\ status \in [Server -> Status]
  /\ lastDelivered \in [Server -> {0} \cup SlotRange]  
  /\ \A s \in Server : \A msg \in rcvdMsg[s] : msg \in Message 
  /\ \A s \in Server, t \in Server : \A k \in DOMAIN inTransit[s][t]: 
        inTransit[s][t][k] \in Message  
  /\ \A snder, rcver \in Server : front[snder][rcver] \in {0} \cup DOMAIN inTransit[snder][rcver]
  /\ \A s \in Server : \A k \in DOMAIN delivered[s]: delivered[s][k] \in BcastMsg    
  /\ \A k \in DOMAIN bcasted : bcasted[k] = BcastMsgInSeq[k]
  *)
TypeInv == 
  /\ \A s \in Server : \A k \in DOMAIN bcastMsgLog[s] : 
        \/ bcastMsgLog[s][k] \in bcasted
        \/ bcastMsgLog[s][k] = BcastMsgNull  
  /\ ballot \in [Server -> BallotRange]
  /\ cballot \in [Server -> BallotRange]
  /\ status \in [Server -> Status]
  /\ lastDelivered \in [Server -> {0} \cup SlotRange]  
  /\ \A s \in Server : rcvdMsg_NormalCase[s] \subseteq Message_NormalCase 
  /\ \A s \in Server : rcvdMsg_RecoveringCase[s] \subseteq Message_RecoveringCase
  /\ \A s \in Server, t \in Server : \A k \in DOMAIN inTransit[s][t] : 
        inTransit[s][t][k] \in Message  
  /\ \A snder, rcver \in Server : 0 <= front[snder][rcver] /\ front[snder][rcver] <= Len(inTransit[snder][rcver])
  /\ \A s \in Server : \A k \in DOMAIN delivered[s]: delivered[s][k] \in bcasted    
  /\ bcasted \subseteq BcastMsg
  
  

(* Integrity: (a) Every server TO-delivers message m at most once.
    
    - For every server s, varialbe delivered[s] is a squences of messages which are delivered by s. Whenever s 
      delivers message m, s adds m to the end of delivered[s].
    - The operator DOMAIN returns the domain of a function, i.e. DOMAIN delivered[s] returns {1, ..., Len(delivered[s])}.
    - Set BcastMsghas possible Broadcast messages. BcastMsgis generated from sequence 
      BcastMsgInSeq which is defined by the user.
    --> Therefore, Integrity can be encoded as: For every message m in BcastMsg, for every server s 
      in Server, if there exist two indices k1 and k2 in DOMAIN delivered[s] such that both delivered[s][k1] and 
      delivered[s][k2] equal m, then k1 equals k2. Formally, we have
        \A m \in BcastMsg: \A s \in Server : 
              (\E k1, k2 \in DOMAIN delivered[s] : (delivered[s][k1] = m /\ delivered[s][k2] = m) 
                                                        => k1 = k2) 
    - However, because every Delivered message is added to sequence[s], instead of (a) we can check that (a1) every 
      element in delivered[s] is unique. Property (a1) can be formalized as: For every server s in Server, for 
      every indices k1 and k2 in DOMAIN delivered[s], if messages delivered[s][k1] and delivered[s][k2] are the same, 
      then these indices k1 and k2 are equal.
 *)                
Integrity ==
  \A s \in Server : \A k1, k2 \in DOMAIN delivered[s] : delivered[s][k1] = delivered[s][k2] => k1 = k2   


(* Validity: If a process TO-delivers message m, then some process TO-broadcasts m before. 
    - In our encoding, we don't specify clients and how clients broadcast messages to servers. 
    - We assume that Broadcast messages and their order are described in the constant sequence BcastMsgInSeq which is 
      defined by the user. 
    - The behavior at line 8 "when received BROADCAST(m)" is formalized as action HandleBcastMsg. Whenever a Broadcast 
      message is processed by HandleBcastMsg, we put this message to the end of sequence bcasted. 
    --> Therefore, we can formalize Validity as following: For every message m, for every server s if s TO-delivers m, 
      then m must appear in bcasted.
 *) 
 (*
Validity == 
  \A s \in Server : \A k \in DOMAIN delivered[s] : 
     \E k0 \in DOMAIN bcasted : bcasted[k0] = delivered[s][k]
     *) 
Validity == 
  \A s \in Server : \A k \in DOMAIN delivered[s] : delivered[s][k] \in bcasted     
     
      
(* There exists server s such that s deliveres m1, but s didn't deliver m2 before delivering m1.
 *)      
DeliverBefore(m1, m2) ==
  \E s \in Server : \E k1 \in DOMAIN delivered[s] : /\ delivered[s][k1] = m1
                                                    /\ \A k2 \in 1..(k1 - 1) : delivered[s][k2] # m2

(* The relation DeliverBefore is asymmetric. In other words, for every pair of different Broadcast messages m1 and m2, it is
   impossible that both DeliverBefore(m1, m2) and DeliverBefore(m2, m1) are correct.
 *) 
GlobalTotalDeliveryOrder == 
  \A m1, m2 \in BcastMsg: m1 # m2 => ~(DeliverBefore(m1, m2) /\ DeliverBefore(m2, m1))
  
(************************ END: TYPE INVARIANT & SAFETY ***********************
 *)  
                  
(************************* START: MESSAGE CONSTRUCTORS ***********************

    - ManyMsgsCtor: constructs a sequence of messages, and is used to replace the loop operator FOR at line 48 in pseudocode.
 *)
OneMsgCtor(snder, rcver, info) == [source |-> snder, dest |-> rcver, data |-> info]

ManyMsgsCtor(snder, rcver, infoSeq) ==
  [ index \in DOMAIN infoSeq |-> OneMsgCtor(snder, rcver, infoSeq[index])] 
(************************* END: MESSAGE CONSTRUCTORS *************************
 *)  

(********* START: DECLARATION FOR SENDING & RECEVING PRIMITIVES ***********

   The primitives for sending one Accept (Commit, NewLeader, or NewState) message from sender source to many receivers 
   in destList: at line 12, 19, 25, and 37 in pseudocode.
 *) 
                        
SendOneMsgToRcvers(source, destList, info) ==   
  inTransit' = [inTransit EXCEPT ![source] = [dest \in Server |->  
                  IF dest \in destList 
                  THEN Append(inTransit[source][dest], OneMsgCtor(source, dest, info))
                  ELSE inTransit[source][dest]]]

SendOneMsgToAll(source, info) ==   
  inTransit' = [inTransit EXCEPT ![source] = [dest \in Server |->  
                  Append(inTransit[source][dest], OneMsgCtor(source, dest, info))]]
                                                        
(* This is a special case of SendOneMsgToRcvers: the list destList has only one element. Perhaps TLC can reason about 
   this expression faster than calling SendOneMsgToRcvers.
 *)     
SendOneMsgToOne(source, dest, info) ==               
  inTransit' = [inTransit EXCEPT ![source][dest] = Append(inTransit[source][dest], 
                                                        OneMsgCtor(source, dest, info))]                               
                                                              

(* This primitive is used to send many Commit messages in one transition - line 48 in pseudocode. Only the action 
   HandleNewStateAckMsg_FirstQuorum executes this primitive.
 *)   
SendManyMsgsToAll(source, infoSeq) ==  
  inTransit' = [inTransit EXCEPT ![source] = [dest \in Server |->                    
                  inTransit[source][dest] \circ ManyMsgsCtor(source, dest, infoSeq)]] 
                      
                      
(* The primitive for receiving one message
    - m is the message which proc rcver has received in this transition.
    - slot is the slot containing m.
    - Increase front[snder][rcver] by 1 to mark that server rcver has received message m.
    - Messages from front'[snder][rcver] to Len(inTransit[snder][rcver]) have not been received.  
    - Push message m to a list of message which server rcver has received.
 *)    
Receive(rcver, snder, m) ==
  /\ front' = [front EXCEPT ![snder][rcver] = front[snder][rcver] + 1]
  /\ IF m.data.type \in MsgStatus_NormalCase
     THEN /\ rcvdMsg_NormalCase' = [rcvdMsg_NormalCase EXCEPT ![rcver] = rcvdMsg_NormalCase[rcver] \cup {m}]
          /\ UNCHANGED rcvdMsg_RecoveringCase 
     ELSE /\ rcvdMsg_RecoveringCase' = [rcvdMsg_RecoveringCase EXCEPT ![rcver] = rcvdMsg_RecoveringCase[rcver] \cup {m}]
          /\ UNCHANGED rcvdMsg_NormalCase
          
(************ END: DECLARATION FOR SENDING & RECEVING PRIMITIVES *************
 *)          
  
                   
(************************ START: THE PROTOCOL ZAB ****************************     
               
  Line 1-7: the initialized states
    - All serveres are Followers.
    - No Broadcast messages are stored at every servers.   
    - Both ballot and cballot are initialized with 0.
    - No messages are delivered.
    - No message is received or in transit.
    - No Broadcast message is processed with action HandleBcastMsg.
 *) 
Init ==  
  /\ status = [s \in Server |-> Follower]  
  /\ bcastMsgLog = [s \in Server |-> (<<>> <: Seq(Int))] 
  /\ ballot = [s \in Server |-> 0]
  /\ cballot = [s \in Server |-> 0]
  /\ lastDelivered = [s \in Server |-> 0]
  /\ delivered = [s \in Server |-> << >>]  
  /\ rcvdMsg_NormalCase = [s \in Server |-> {}]
  /\ rcvdMsg_RecoveringCase = [s \in Server |-> {}]
  /\ inTransit = [s \in Server |-> [q \in Server |-> << >> ]]
  /\ front = [s \in Server |-> [q \in Server |-> 0]]    
  /\ bcasted = {}
                      
  
(* Line 8-12: Here we do not encode how a client sends a BcastMsgto the Leader. We just assume that the Leader 
   has received message m from somewhere. Moreover, we remove variable next in the pseudocode because our specification 
   maintains an invariant next = Len(bcastMsgLog[self]), if self is the current leader.
 *)
HandleBcastMsg(self, msg) ==
  /\ status[self] = Leader  
  /\ UNCHANGED << status, ballot, cballot, lastDelivered, front, delivered, rcvdMsg_RecoveringCase, rcvdMsg_NormalCase >>
  /\ LET index == Len(bcastMsgLog[self]) + 1         
         info == [type |-> Accept, ballot |-> ballot'[self], slot |-> index, bcast |-> msg]               
     IN /\ bcastMsgLog' = [bcastMsgLog EXCEPT ![self] = Append(bcastMsgLog[self], msg)]                                     
        /\ SendOneMsgToAll(self, info) 
        

(* Line 13-16: Server self has received Accept message m from server snder, and responses AcceptAck.
   TODO: check whether there is a gap in the new log bcastMsgLog'[self].
 *)
HandleAcceptMsg(self, snder, msg) ==  
  IF /\ ballot[self] = msg.data.ballot
     /\ status[self] \in { Leader, Follower }     
  THEN LET slot == msg.data.slot
           dom == 1..Max(Len(bcastMsgLog[self]), slot)
           source == self
           dest == snder
           info == [type |-> AcceptAck, ballot |-> msg.data.ballot, slot |-> msg.data.slot]
       IN /\ bcastMsgLog' = [bcastMsgLog EXCEPT ![self] = [k \in dom |-> 
                            IF k \in DOMAIN bcastMsgLog[self] /\ k # slot THEN bcastMsgLog[self][k]
                            ELSE IF k = slot THEN msg.data.bcast
                                 ELSE BcastMsgNull]]
          /\ UNCHANGED << ballot, cballot, status, lastDelivered, delivered, bcasted >> 
          /\ SendOneMsgToOne(source, dest, info)
  ELSE UNCHANGED << bcastMsgLog, ballot, cballot, status, lastDelivered,  
                    inTransit, delivered, bcasted >>       


(* Line 17-19: Server self has received an AcceptAck message for m. There was no quorum for m before, and now server self 
   knows that the majority accepts m. Server self sends Commit messages to all.
 *)
HandleAcceptAckMsg(self, msg) == 
  IF /\ status[self] = Leader
     /\ ballot[self] = msg.data.ballot
  THEN LET similarMsg == {elem \in rcvdMsg_NormalCase'[self] : 
                                /\ elem.data.type = AcceptAck
                                /\ elem.data.ballot = msg.data.ballot 
                                /\ elem.data.slot = msg.data.slot}
           snderList == {elem.source : elem \in similarMsg}
           bcastMsg == bcastMsgLog[self][msg.data.slot]
           info == [type |-> Commit, ballot |-> msg.data.ballot, slot |-> msg.data.slot, 
                       bcast |-> bcastMsg] 
       IN IF Cardinality(snderList) = MajorGuard
          THEN /\ UNCHANGED << bcastMsgLog, ballot, cballot, status, lastDelivered, delivered, bcasted >>
               /\ SendOneMsgToAll(self, info)
          ELSE UNCHANGED << bcastMsgLog, ballot, cballot, status, lastDelivered, inTransit, 
                              delivered, bcasted >>   
  ELSE UNCHANGED << bcastMsgLog, ballot, cballot, status, lastDelivered,  
                      inTransit, delivered, bcasted >>          
        
(* Line 20-23: The first time that server self receives a Commit message for Broadcast message m at the position k in its 
   delivery sequence, and it delivers m.
 *)
HandleCommitMsg(self, msg) == 
  IF /\ status[self] \in { Leader, Follower }
     /\ ballot[self] = msg.data.ballot
     /\ lastDelivered[self] < msg.data.slot
  THEN LET slot == msg.data.slot
           dom == 1..Max(Len(bcastMsgLog[self]), slot)
       IN /\ lastDelivered' = [lastDelivered EXCEPT ![self] = msg.data.slot]
          /\ bcastMsgLog' = [bcastMsgLog EXCEPT ![self] = [k \in dom |-> 
                        IF k \in DOMAIN bcastMsgLog[self] /\ k # slot THEN bcastMsgLog[self][k]
                        ELSE IF k = slot THEN msg.data.bcast
                             ELSE BcastMsgNull]]                                                   
          /\ delivered' = [delivered EXCEPT ![self] = Append(delivered[self], msg.data.bcast)]
          /\ UNCHANGED << ballot, cballot, status, inTransit, bcasted >>     
  ELSE UNCHANGED << lastDelivered, delivered, bcastMsgLog, ballot, cballot, status, inTransit, bcasted >>
     

(* Line 24-25: Wants to become a Leader in a highter ballot, and sends NewLeader messages to all, except it.
 *)
Recover(self) == 
  \E newBallot \in (ballot[self] + 1)..BallotMax:
    /\ status[self] = Follower
    /\ IsLeader[newBallot] = self
    /\ UNCHANGED << bcastMsgLog, cballot, lastDelivered, rcvdMsg_NormalCase, rcvdMsg_RecoveringCase, front, delivered, bcasted >>
    /\ LET info == [type |-> NewLeader, ballot |-> newBallot]
       IN /\ status' = [status EXCEPT ![self] = Recovering]
          /\ ballot' = [ballot EXCEPT ![self] = newBallot]
          /\ SendOneMsgToRcvers(self, Server \ {self}, info)

(* Line 26-30: Trying to join a higher ballot.
 *)
HandleNewLeaderMsg(self, LeaderCand, msg) == 
  IF ballot[self] < msg.data.ballot 
  THEN /\ status' = [status EXCEPT ![self] = Recovering]
       /\ ballot' = [ballot EXCEPT ![self] = msg.data.ballot]
       /\ UNCHANGED << bcastMsgLog, cballot, lastDelivered, delivered, bcasted >>
       /\ LET info == [type |-> NewLeaderAck, ballot |-> ballot'[self], cballot |-> cballot'[self], 
                         log |-> bcastMsgLog'[self]]
          IN SendOneMsgToOne(self, LeaderCand, info)
  ELSE UNCHANGED << lastDelivered, delivered, bcastMsgLog, ballot, cballot, status, inTransit, bcasted >>                      
  


PickGreaterLog(log1, log2) ==
  IF \/ log1.data.cballot < log2.data.cballot
     \/ /\ log1.data.cballot = log2.data.cballot
        /\ Len(log1.data.log) <= Len(log2.data.log)
  THEN log2
  ELSE log1
  
(*  
UNROLL_DEFAULT_PickGreatestLog == 0 
UNROLL_TIMES_PickGreatestLog ==  BcastMsgInSeqLen
 *)
 
UNROLL_DEFAULT_PickGreatestLog == 0 
UNROLL_TIMES_PickGreatestLog == 2 
  
RECURSIVE PickGreatestLog(_)


  
PickGreatestLog(setLog) ==
 IF Cardinality(setLog) = 1 
 THEN CHOOSE elem \in setLog : TRUE
 ELSE LET log1 == CHOOSE x \in setLog : TRUE
          log2 == PickGreatestLog(setLog \ {log1})
      IN PickGreaterLog(log1, log2)
             
  
(* Line 31-37: The first time server self heard message msg from a quorum (including itself). It sends NewState 
   messages to others.
 *)
HandleNewLeaderAckMsg(self, msg) ==
  IF /\ status[self] = Recovering  
     /\ ballot[self] = msg.data.ballot
       
  THEN LET info0 == [type |-> NewLeaderAck, ballot |-> ballot[self], cballot |-> cballot[self], 
                    log |-> bcastMsgLog[self]]
           selfMsg == OneMsgCtor(self, self, info0)                      
           similarMsg == {elem \in rcvdMsg_RecoveringCase'[self] : 
                                  /\ elem.data.type = NewLeaderAck
                                  /\ elem.data.ballot = msg.data.ballot }
                           \cup {selfMsg}                                                
           snderList == {elem.source : elem \in similarMsg}        
       IN IF  Cardinality(snderList) = MajorGuard                   
          THEN LET msg0 == PickGreatestLog(similarMsg)                   
                   currLog == msg0.data.log
                   currBallot == msg0.data.ballot
                   info == [type |-> NewState, ballot |-> currBallot, log |-> currLog]
               IN /\ bcastMsgLog' = [bcastMsgLog EXCEPT ![self] = currLog]                   
                  /\ cballot' = [cballot EXCEPT ![self] = currBallot]                      
                  /\ UNCHANGED << ballot, status, lastDelivered, delivered, bcasted >>                          
                  /\ SendOneMsgToRcvers(self, Server \ {self}, info)
          ELSE UNCHANGED << bcastMsgLog, ballot, cballot, status, lastDelivered, delivered, 
                            inTransit, bcasted >>               
  ELSE UNCHANGED << bcastMsgLog, ballot, cballot, status, lastDelivered, delivered, 
                            inTransit, bcasted >>                                                           
                        

(* Line 38-44: Receives a NewState message in a higher ballot, sends the acknoledgement, and becomes a follower.
 *) 
HandleNewStateMsg(self, LeaderCand, msg) ==   
  IF ballot[self] <= msg.data.ballot
  THEN /\ ballot'= [ballot EXCEPT ![self] = msg.data.ballot]
       /\ cballot'= [cballot EXCEPT ![self] = msg.data.ballot]
       /\ bcastMsgLog' = [bcastMsgLog EXCEPT ![self] = msg.data.log]
       /\ status' = [status EXCEPT ![self] = Follower]
       /\ UNCHANGED << lastDelivered, delivered, bcasted >>
       /\ LET info == [type |-> NewStateAck, ballot |-> ballot'[self]]
          IN SendOneMsgToOne(self, LeaderCand, info)
  ELSE UNCHANGED << bcastMsgLog, ballot, cballot, status, lastDelivered,  
                    inTransit, delivered, bcasted >>



(* Line 45-48: The majority is ready to join a new ballot with the leader self. This action is executed for the first 
   quorum. Commit messages are sent to all.
 *) 
HandleNewStateAckMsg(self, msg) == 
  IF /\ status[self] = Recovering
     /\ ballot[self] = msg.data.ballot  
  THEN LET similarMsg == {elem \in rcvdMsg_RecoveringCase'[self] : 
                                /\ elem.data.type = NewStateAck
                                /\ elem.data.ballot = msg.data.ballot}
           snderList == {elem.source : elem \in similarMsg}        
       IN IF Cardinality(snderList) + 1 = MajorGuard
          THEN /\ status' = [status EXCEPT ![self] = Leader]
               /\ UNCHANGED << bcastMsgLog, ballot, cballot, lastDelivered, delivered, bcasted >>        
               /\ LET CommitInfoSeq == [k \in DOMAIN bcastMsgLog[self] |-> 
                                         [type |-> Commit, ballot |-> ballot'[self], slot |-> k,  
                                            bcast |-> bcastMsgLog[self][k]]]                
                  IN SendManyMsgsToAll(self, CommitInfoSeq)
          ELSE /\ UNCHANGED << bcastMsgLog, ballot, cballot, status, lastDelivered,  
                          inTransit,  delivered, bcasted >>
  ELSE UNCHANGED << bcastMsgLog, ballot, cballot, status, lastDelivered,  
                    inTransit, delivered, bcasted >>                           
  
  


(* This loop is executed when the execution reaches the bound. This is to avoid the deadlock warning in TLC when 
   the deadlock is really a good thing.
 *)                   
ReachBounds ==
  /\ Cardinality(bcasted) = Cardinality(BcastMsg)
  /\ \A snder, rcver \in Server : front[snder][rcver] = Len(inTransit[snder][rcver])
  /\ UNCHANGED vars                   
  
HandleMsg(snder, rcver, msg) ==
  \/ /\ msg.data.type = Accept 
     /\ HandleAcceptMsg(rcver, snder, msg)  
  \/ /\ msg.data.type = AcceptAck
     /\ HandleAcceptAckMsg(rcver, msg)
  \/ /\ msg.data.type = Commit
     /\ HandleCommitMsg(rcver, msg)     
  \/ /\ msg.data.type = NewLeader
     /\ HandleNewLeaderMsg(rcver, snder, msg)
  \/ /\ msg.data.type = NewLeaderAck
     /\ HandleNewLeaderAckMsg(rcver, msg)     
  \/ /\ msg.data.type = NewState
     /\ HandleNewStateMsg(rcver, snder, msg)
  \/ /\ msg.data.type = NewStateAck        
     /\ HandleNewStateAckMsg(rcver, msg)
 


         
   
Next ==          
  \/ /\ Cardinality(bcasted) < Cardinality(BcastMsg)
     /\ LET k == Cardinality(bcasted) + 1
            msg == BcastMsgInSeq[k]
        IN \E s \in Server :  
              /\ status[s] = Leader
              /\ HandleBcastMsg(s, msg)
              /\ bcasted' = bcasted \cup { msg }  
  \/ \E rcver, snder \in Server :
        /\ front[snder][rcver] < Len(inTransit[snder][rcver])
        /\ LET slot == front[snder][rcver] + 1
               msg == inTransit[snder][rcver][slot]
           IN /\ Receive(rcver, snder, msg)
              /\ HandleMsg(snder, rcver, msg)
  \/ \E s \in Server : Recover(s)    
         
  \/ ReachBounds
       
  
(* The specification
 *)              
Spec == Init /\ [][Next]_vars



(*************************** END: THE PROTOCOL ZAB ***************************
 *)
         
=============================================================================
\* Modification History
\* Last modified Tue Mar 09 08:32:07 CET 2021 by tran
\* Last modified Thu Nov 29 12:24:38 CET 2018 by tthai
\* Created Wed Nov 28 13:22:35 CET 2018 by tthai
